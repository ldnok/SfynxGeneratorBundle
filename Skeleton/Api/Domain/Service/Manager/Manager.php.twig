<?php

namespace {{ projectName }}\Domain\Service\{{ entityName }}\Manager;

use Sfynx\DddBundle\Layer\Domain\Service\Generalisation\Factory\RepositoryFactoryInterface;
use Sfynx\DddBundle\Layer\Domain\Service\Generalisation\Manager\AbstractManager;
use Sfynx\DddBundle\Layer\Domain\Service\Generalisation\Manager\TraitDeleteMany;
use Sfynx\DddBundle\Layer\Domain\Service\Generalisation\Manager\TraitDeleteOne;
use Sfynx\DddBundle\Layer\Domain\Service\Generalisation\Manager\TraitGetAll;
use Sfynx\DddBundle\Layer\Domain\Service\Generalisation\Manager\TraitGetByIds;
use Sfynx\DddBundle\Layer\Domain\Service\Generalisation\Manager\TraitGetOne;
use Sfynx\DddBundle\Layer\Domain\Service\Generalisation\Manager\TraitSearchBy;
use Sfynx\DddBundle\Layer\Domain\Generalisation\Processor\ProcessorInterface;
use Sfynx\DddBundle\Layer\Domain\Generalisation\Processor\TraitProcessor;
use Sfynx\DddBundle\Layer\Infrastructure\Logger\Generalisation\TraitLogger;
use {{ projectName }}\Domain\Entity\{{ entityName }};

/**
 * Class {{ entityName }}Manager
 *
 * @category {{ projectName }}
 * @package Domain
 * @subpackage Service\Manager
 */
class {{ entityName }}Manager extends AbstractManager implements ProcessorInterface
{
    use TraitProcessor;
    use TraitLogger;
    use TraitGetAll;
    use TraitGetOne;
    use TraitGetByIds;
    use TraitDeleteOne;
    use TraitDeleteMany;
    use TraitSearchBy;

    /**
     * Hydrate the entity then call the New Repository.
{% for field in entityFields %}     * @param {{ field.type }} ${{ field.name }}
{% endfor %}
     * @return {{ entityName }}
     */
    public function create({{ constructorArgs }})
    {
        //hydrate with VO
        $entity = {{ entityName }}::makeInstance($_SERVER['HTTP_X_TENANT_ID'], {{ constructorArgs }});

        //execute prepersist processor
        $this->executeProcess('prepersist_create', $entity);

        // Persistence handler
        $object = new \stdClass();
        $object->entity = $entity;
        $this->factory->buildRepository(RepositoryFactoryInterface::NEW_REPOSITORY)->execute($object);

        //execute postpersist processor
        $this->executeProcess('postpersist_create', $entity);

        // Log handler
        $this->logger->info('{{ entityName }} ' . $entity->getId() . ' has been saved.', ['{{ entityName|lower }}' => $entity]);

        return $entity;
    }

    /**
     * Get the current entity, hydrate it with updated values and call the Update Repository.
{% for field in entityFields %}     * @param {{ field.type }} ${{ field.name }}
{% endfor %}
     * @return {{ entityName }}
     */
    public function update({{ constructorArgs }})
    {
        //get {{ entityName }} by id
        $object = new \stdClass();
{% for field in entityFields %}
{% if field.type == "id" %}
        $object->entityId = ${{ field.name }}->id();
        $entity = $this->factory->buildRepository(RepositoryFactoryInterface::ONE_REPOSITORY)->execute($object);
{% endif %}
{% endfor %}

        if (null === $entity) {
            //todo: manage exception
        }

        //hydrate with VO
{% for field in entityFields %}
        $entity->set{{ field.name|capitalize }}(${{ field.name }});
{% endfor %}

        //execute prepersist processor
        $this->executeProcess('prepersist_update', $entity);

        // Persistance handler
        $object->entity = $entity;
        $this->factory->buildRepository(RepositoryFactoryInterface::UPDATE_REPOSITORY)->execute($object);

        //execute postpersist processor
        $this->executeProcess('postpersist_update', $entity);

        // Log handler
        $this->logger->info('{{ entityName }} ' . $entity->getId() . ' has been saved.', ['{{ entityName|lower }}' => $entity]);

        return $entity;
    }
}
